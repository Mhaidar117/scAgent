"""Tests for final graph analysis functionality."""

import tempfile
import shutil
from pathlib import Path
import numpy as np
import pytest

from scqc_agent.state import SessionState
from scqc_agent.tools.graph import final_graph

try:
    import scanpy as sc
    import anndata as ad
    SCANPY_AVAILABLE = True
except ImportError:
    SCANPY_AVAILABLE = False


@pytest.fixture
def synthetic_adata_with_representations():
    """Create synthetic AnnData with multiple representations for testing."""
    if not SCANPY_AVAILABLE:
        pytest.skip("Scanpy not available")
    
    # Create synthetic data
    np.random.seed(42)
    n_obs, n_vars = 200, 300
    
    # Create count data
    X = np.random.negative_binomial(8, 0.3, size=(n_obs, n_vars)).astype(np.float32)
    
    # Create AnnData object
    adata = ad.AnnData(X=X)
    adata.var_names = [f"Gene_{i}" for i in range(n_vars)]
    adata.obs_names = [f"Cell_{i}" for i in range(n_obs)]
    
    # Add batch information
    adata.obs['batch'] = np.random.choice(['batch1', 'batch2'], n_obs)
    adata.obs['SampleID'] = np.random.choice(['sample1', 'sample2'], n_obs)
    
    # Add synthetic representations (what would be generated by scVI, scAR, etc.)
    adata.obsm['X_pca'] = np.random.normal(0, 1, (n_obs, 50))
    adata.obsm['X_scVI'] = np.random.normal(0, 1, (n_obs, 30))  # Lower dimensional
    adata.obsm['X_scAR'] = np.random.normal(0, 1, (n_obs, n_vars))  # Same as original
    
    return adata


@pytest.fixture
def temp_state():
    """Create temporary state for testing."""
    temp_dir = tempfile.mkdtemp()
    state = SessionState(run_id="test_final_graph")
    
    yield state, temp_dir
    
    # Cleanup
    shutil.rmtree(temp_dir, ignore_errors=True)


def test_final_graph_no_dependencies():
    """Test final graph behavior when dependencies are not available."""
    # Temporarily mock availability flags
    import scqc_agent.tools.graph as graph_module
    original_scanpy = graph_module.SCANPY_AVAILABLE
    
    # Test with no scanpy
    graph_module.SCANPY_AVAILABLE = False
    
    try:
        state = SessionState()
        result = final_graph(state)
        
        assert "Scanpy not available" in result.message
        assert len(result.artifacts) == 0
        assert len(result.state_delta) == 0
    finally:
        graph_module.SCANPY_AVAILABLE = original_scanpy


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_no_data_loaded(temp_state):
    """Test final graph behavior when no data is loaded."""
    state, temp_dir = temp_state
    
    result = final_graph(state)
    
    assert result.message.startswith("❌")
    assert "No AnnData file loaded" in result.message or "failed" in result.message
    assert len(result.artifacts) == 0


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_missing_representation(synthetic_adata_with_representations, temp_state):
    """Test final graph with missing representation."""
    state, temp_dir = temp_state
    
    # Save synthetic data
    adata_path = Path(temp_dir) / "test_data.h5ad"
    synthetic_adata_with_representations.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Test with non-existent representation
    result = final_graph(state, use_rep="X_nonexistent")
    
    assert result.message.startswith("❌")
    assert "not found in adata.obsm" in result.message
    assert "Available:" in result.message


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_small_dataset(synthetic_adata_with_representations, temp_state):
    """Test final graph with very small dataset."""
    state, temp_dir = temp_state
    
    # Create very small dataset
    small_adata = synthetic_adata_with_representations[:5, :].copy()  # Only 5 cells
    
    adata_path = Path(temp_dir) / "small_data.h5ad"
    small_adata.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Should fail due to too few cells
    result = final_graph(state, use_rep="X_scVI")
    
    assert result.message.startswith("❌")
    assert "Too few cells" in result.message
    assert "10" in result.message  # Minimum required


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_low_dimensional_representation(synthetic_adata_with_representations, temp_state):
    """Test final graph with low-dimensional representation."""
    state, temp_dir = temp_state
    
    # Create data with 1D representation
    adata = synthetic_adata_with_representations.copy()
    adata.obsm['X_1d'] = np.random.normal(0, 1, (len(adata), 1))
    
    adata_path = Path(temp_dir) / "test_data.h5ad"
    adata.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Should fail due to too few dimensions
    result = final_graph(state, use_rep="X_1d")
    
    assert result.message.startswith("❌")
    assert "too few dimensions" in result.message
    assert "Need at least 2" in result.message


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_basic_functionality(synthetic_adata_with_representations, temp_state):
    """Test basic final graph functionality."""
    state, temp_dir = temp_state
    
    # Save synthetic data
    adata_path = Path(temp_dir) / "test_data.h5ad"
    synthetic_adata_with_representations.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Run final graph analysis
    result = final_graph(
        state,
        use_rep="X_scVI",
        resolution=1.0,
        seed=42,
        n_neighbors=15
    )
    
    # Should complete successfully
    assert not result.message.startswith("❌"), f"Final graph failed: {result.message}"
    assert result.state_delta is not None
    
    # Check expected state updates
    assert "final_n_clusters" in result.state_delta
    assert "final_largest_cluster_size" in result.state_delta
    assert "final_largest_cluster_pct" in result.state_delta
    assert "final_smallest_cluster_size" in result.state_delta
    assert "final_connectivity_rate" in result.state_delta
    assert "final_cluster_balance" in result.state_delta
    assert "final_graph_params" in result.state_delta
    assert "pipeline_complete" in result.state_delta
    assert result.state_delta["pipeline_complete"] == True
    
    # Check graph parameters
    params = result.state_delta["final_graph_params"]
    assert params["use_rep"] == "X_scVI"
    assert params["resolution"] == 1.0
    assert params["seed"] == 42
    assert params["n_dims"] == 30  # X_scVI dimensions
    
    # Should have artifacts (at least UMAP and cluster counts)
    assert len(result.artifacts) >= 2
    assert any("umap_final.png" in str(artifact) for artifact in result.artifacts)
    assert any("cluster_counts_final.csv" in str(artifact) for artifact in result.artifacts)
    
    # Should have citations
    assert len(result.citations) > 0
    assert any("Wolf" in citation for citation in result.citations)
    assert any("UMAP" in citation for citation in result.citations)
    assert any("Leiden" in citation for citation in result.citations)


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_different_representations(synthetic_adata_with_representations, temp_state):
    """Test final graph with different representations."""
    state, temp_dir = temp_state
    
    # Save synthetic data
    adata_path = Path(temp_dir) / "test_data.h5ad"
    synthetic_adata_with_representations.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Test with different representations
    representations = ["X_pca", "X_scVI", "X_scAR"]
    
    for use_rep in representations:
        state.history = []  # Reset for each test
        result = final_graph(
            state,
            use_rep=use_rep,
            resolution=0.5,
            seed=42
        )
        
        if not result.message.startswith("❌"):
            # Should complete successfully
            assert "final_n_clusters" in result.state_delta
            assert result.state_delta["final_graph_params"]["use_rep"] == use_rep
            assert len(result.artifacts) >= 2


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_resolution_parameter(synthetic_adata_with_representations, temp_state):
    """Test final graph with different resolution parameters."""
    state, temp_dir = temp_state
    
    # Save synthetic data
    adata_path = Path(temp_dir) / "test_data.h5ad"
    synthetic_adata_with_representations.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Test with different resolutions
    resolutions = [0.1, 0.5, 1.0, 2.0]
    
    results = []
    for resolution in resolutions:
        state.history = []  # Reset for each test
        result = final_graph(
            state,
            use_rep="X_scVI",
            resolution=resolution,
            seed=42
        )
        
        if not result.message.startswith("❌"):
            results.append((resolution, result.state_delta.get("final_n_clusters", 0)))
            assert result.state_delta["final_graph_params"]["resolution"] == resolution
    
    # Generally, higher resolution should lead to more clusters (though not guaranteed with small synthetic data)
    if len(results) > 1:
        resolutions_tested = [r[0] for r in results]
        assert min(resolutions_tested) < max(resolutions_tested)


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_with_batch_visualization(synthetic_adata_with_representations, temp_state):
    """Test final graph with batch information (should create additional visualization)."""
    state, temp_dir = temp_state
    
    # Save synthetic data (already has batch information)
    adata_path = Path(temp_dir) / "test_data.h5ad"
    synthetic_adata_with_representations.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Run final graph analysis
    result = final_graph(
        state,
        use_rep="X_scVI",
        resolution=1.0,
        seed=42
    )
    
    if not result.message.startswith("❌"):
        # Should have at least 3 artifacts if batch plot is created
        # (umap_final.png, cluster_counts_final.csv, umap_final_with_batch.png)
        assert len(result.artifacts) >= 2
        
        # Check if batch visualization was created
        has_batch_plot = any("umap_final_with_batch" in str(artifact) for artifact in result.artifacts)
        # Note: This depends on matplotlib being available, so we don't assert it


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_cluster_balance_calculation(synthetic_adata_with_representations, temp_state):
    """Test that cluster balance is calculated correctly."""
    state, temp_dir = temp_state
    
    # Save synthetic data
    adata_path = Path(temp_dir) / "test_data.h5ad"
    synthetic_adata_with_representations.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Run final graph analysis
    result = final_graph(
        state,
        use_rep="X_scVI",
        resolution=1.0,
        seed=42
    )
    
    if not result.message.startswith("❌"):
        # Cluster balance should be between 0 and 1
        balance = result.state_delta.get("final_cluster_balance", -1)
        assert 0 <= balance <= 1
        
        # If there's only 1 cluster, balance should be 0 (or very close due to log2(1)=0)
        n_clusters = result.state_delta.get("final_n_clusters", 0)
        if n_clusters == 1:
            assert balance < 0.01  # Should be very close to 0


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_state_management(synthetic_adata_with_representations, temp_state):
    """Test that final graph properly manages state updates."""
    state, temp_dir = temp_state
    
    # Save synthetic data
    adata_path = Path(temp_dir) / "test_data.h5ad"
    synthetic_adata_with_representations.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Run final graph analysis
    result = final_graph(state, use_rep="X_scVI")
    
    # State should be properly updated even on failure
    if result.message.startswith("❌"):
        # Should handle failure gracefully
        assert len(result.state_delta) == 0
        assert len(result.artifacts) == 0
    else:
        # On success, should have proper state updates
        assert "final_n_clusters" in result.state_delta
        assert "pipeline_complete" in result.state_delta


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_reproducibility(synthetic_adata_with_representations, temp_state):
    """Test that final graph produces reproducible results with same seed."""
    state, temp_dir = temp_state
    
    # Save synthetic data
    adata_path = Path(temp_dir) / "test_data.h5ad"
    synthetic_adata_with_representations.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Run final graph analysis twice with same seed
    seed = 123
    result1 = final_graph(state, use_rep="X_scVI", seed=seed, resolution=1.0)
    
    # Reset state for second run
    state.history = []
    state.artifacts = {}
    
    result2 = final_graph(state, use_rep="X_scVI", seed=seed, resolution=1.0)
    
    # Results should be identical (or very similar) if both succeeded
    if (not result1.message.startswith("❌") and 
        not result2.message.startswith("❌")):
        
        # Number of clusters should be the same
        assert result1.state_delta["final_n_clusters"] == result2.state_delta["final_n_clusters"]
        
        # Connectivity rates should be very similar
        conn1 = result1.state_delta["final_connectivity_rate"]
        conn2 = result2.state_delta["final_connectivity_rate"]
        assert abs(conn1 - conn2) < 0.1  # Small tolerance for floating point differences


@pytest.mark.skipif(not SCANPY_AVAILABLE, reason="Scanpy not available")
def test_final_graph_parameters_validation(synthetic_adata_with_representations, temp_state):
    """Test final graph parameter validation."""
    state, temp_dir = temp_state
    
    # Save synthetic data
    adata_path = Path(temp_dir) / "test_data.h5ad"
    synthetic_adata_with_representations.write(adata_path)
    
    state.metadata["adata_path"] = str(adata_path)
    
    # Test various parameter combinations
    test_params = [
        {"use_rep": "X_scVI", "resolution": 0.5, "seed": 42, "n_neighbors": 10},
        {"use_rep": "X_pca", "resolution": 1.0, "seed": 123, "n_neighbors": 20},
        {"use_rep": "X_scAR", "resolution": 2.0, "seed": 456, "n_neighbors": 5}
    ]
    
    for params in test_params:
        state.history = []  # Reset for each test
        result = final_graph(state, **params)
        
        # Should either work or fail gracefully
        assert result.message is not None
        assert result.state_delta is not None
        assert result.artifacts is not None
        assert result.citations is not None
        
        # If successful, parameters should be recorded correctly
        if not result.message.startswith("❌"):
            recorded_params = result.state_delta.get("final_graph_params", {})
            for key, value in params.items():
                if key in recorded_params:
                    assert recorded_params[key] == value


if __name__ == "__main__":
    pytest.main([__file__])
